package parser;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import source.ErrorHandler;
import source.Errors;
import source.LinePositions;
import source.Position;
import syms.Constants;
import syms.Predefined;
import syms.Scope;
import syms.SymEntry;
import syms.SymEntry.TypeEntry;
import syms.SymbolTable;
import syms.Type;
import tree.ConstExp;
import tree.DeclNode;
import tree.ExpNode;
import tree.Operator;
import tree.StatementNode;
import tree.Tree;

/**
 * class Parser - PL0 recursive descent parser. To understand how this parser
 *  works read the notes of recursive descent parsing.
 * @version $Revision: 22 $  $Date: 2014-05-20 15:14:36 +1000 (Tue, 20 May 2014) $ 
 *
 *  The syntax analyzer recognises a PL0 program according to the following
 *  syntax specification using a recursive descent parser. It constructs
 *  the corresponding abstract syntax tree and skeleton symbol table.
 *  PL0 EBNF Grammar:
 *  Program => Block ENDOFFILE 
 *  Block =>  { Declaration  } CompoundStatement 
 *  Declaration => ConstDefList | TypeDefList | VarDeclList | ProcedureDef  
 *  ConstDefList => KW_CONST ConstDef  { ConstDef  } 
 *  ConstDef => IDENTIFIER EQUALS Constant SEMICOLON 
 *  Constant =>  NUMBER | IDENTIFIER | MINUS Constant 
 *  TypeDefList => KW_TYPE TypeDef  { TypeDef  } 
 *  TypeDef => IDENTIFIER EQUALS Type SEMICOLON 
 *         | KW_ OBJECT IDENTIFIER EQUALS ObjType SEMICOLON 
 *  Type => TypeIdentifier | SubrangeType 
 *  ObjType => LPAREN VarDeclList RPAREN 
 *  TypeIdentifier => IDENTIFIER 
 *  SubrangeType => LBRACKET Constant RANGE Constant RBRACKET 
 *  VarDeclList => KW_ VAR VarDecl  { VarDecl  } 
 *  VarDecl => [KW_GLOBAL |KW_ABSTRACT] IDENTIFIER COLON TypeIdentifier SEMICOLON 
 *  ProcedureDef => ProcedureHead EQUALS Block SEMICOLON 
 *  ProcedureHead => TYPE KW_PROCEDURE IDENTIFIER LPAREN FormalParameters RPAREN 
 *  FormalParamters => TYPE IDENTIFIER  {, TYPE IDENTIFIER } 
 *  CompoundStatement => KW_BEGIN StatementList KW_END | LCURLY StatementList RCURLY 
 *  StatementList => Statement  { SEMICOLON Statement  } 
 *  Statement => WhileStatement | IfStatement | Assignment | ReturnStatement | RepeatUntilStatement |
 *  WhileStatement | LockStatement | UnlockStatement | CasStatement | CompoundStatement 
 *  Assignment => LValue ASSIGN Condition 
 *  WhileStatement => KW_WHILE Condition KW_DO Statement 
 *  DoWhileStatement => KW_DO Statement KW_WHILE Condition 
 *  RepeatUntilStatment => KW_REPEAT Statement KW_ UNTIL Condition 
 *  IfStatement => KW_IF Condition KW_THEN Statement KW_ELSE Statement 
 *  CasStetement  => KW_CAS LPAREN Exp, Exp, Exp RPAREN 
 *  ReturnStatenemt => KW_ RETURN [ KW_VOID \ (LPAREN Exp  {, Exp  } RPAREN) ] 
 *  Condition => Exp [ RelOp Exp ] 
 *  RelOp => EQUALS | NEQUALS | LEQUALS | LESS | GREATER | GEQUALS  
 *  Exp => ([ PLUS | MINUS ] Term    { ( PLUS | MINUS ) Term  }) | CasExp  
 *  CasExp => KW_CAS LPAREN Exp, Exp, Exp RPAREN 
 *  Term  => Factor  { ( TIMES \ DIVIDE | MODULO ) Factor  } 
 *  Factor  => LPAREN Condition RPAREN | NUMBER | LValue 
 *  LValue => IDENTIFIER  {PERIOD IDENTIFIER } 
 *
 *  where any constructs not defined by the above productions
 *  are terminal symbols generated by the lexical analyser.
 */
public class Parser {

    /***************** Start Sets for parsing rules **********************/

    /** Set of tokens that may start an LValue. */
    private final static TokenSet LVALUE_START_SET =
        new TokenSet( Token.IDENTIFIER );
    /** Set of tokens that may start a Statement. */
    private final static TokenSet STATEMENT_START_SET =
        LVALUE_START_SET.union( Token.KW_WHILE, Token.KW_IF, Token.KW_RETURN,
          Token.KW_CALL, Token.KW_BEGIN, Token.LCURLY, Token.KW_REPEAT,
          Token.KW_DO, Token.KW_CAS, Token.KW_BREAK, Token.KW_CONTINUE, 
          Token.KW_LOCK, Token.KW_UNLOCK);
    /** Set of tokens that may start a compound Statement */
    private final static TokenSet COMPOUND_STATEMENT_START_SET = 
        new TokenSet( Token.KW_BEGIN, Token.LCURLY );
    /** Set of tokens that may start a Declaration. */
    private final static TokenSet DECLARATION_START_SET =
        new TokenSet( Token.KW_CONST, Token.KW_TYPE, Token.KW_VAR, 
          Token.KW_PROCEDURE );
    /** Set of tokens that may start a Block. */
    private final static TokenSet BLOCK_START_SET =
        DECLARATION_START_SET.union( Token.KW_BEGIN, Token.LCURLY );
    /** Set of tokens that may start a Constant. */
    private final static TokenSet CONSTANT_START_SET = 
        new TokenSet( Token.IDENTIFIER, Token.NUMBER, Token.MINUS );
    /** Set of tokens that may start a Type. */
    private final static TokenSet TYPE_START_SET = 
        new TokenSet( Token.IDENTIFIER, Token.LBRACKET );
    /** Set of tokens that may start a type definition */
    private final static TokenSet TYPE_DEF_START_SET = 
            new TokenSet( Token.IDENTIFIER, Token.KW_OBJECT );
    /** Set of tokens that may start a Factor. */
    private final static TokenSet FACTOR_START_SET = 
        LVALUE_START_SET.union( Token.NUMBER, Token.LPAREN );
    /** Set of tokens that may start a Term. */
    private final static TokenSet TERM_START_SET = 
        FACTOR_START_SET;
    /** Set of tokens that may start an Expression. */
    private final static TokenSet EXP_START_SET =
        TERM_START_SET.union( Token.PLUS, Token.MINUS );
    /** Set of tokens that may start a Condition. */
    private final static TokenSet CONDITION_START_SET =
        EXP_START_SET.union( Token.KW_CAS );
    /** Set of tokens that may start a variable declaration */
    private final static TokenSet VAR_DECL_START_SET = 
        new TokenSet (Token.IDENTIFIER, Token.KW_GLOBAL, Token.KW_ABSTRACT );

    /************ Operation sets for expressions ***************************/
    /** Set of tokens representing relational operators. */
    private final static TokenSet REL_OPS_SET =
        new TokenSet( Token.EQUALS, Token.NEQUALS, Token.LESS, Token.GREATER,
          Token.LEQUALS, Token.GEQUALS );
    /** Set of tokens for expression operators. */
    private final static TokenSet EXP_OPS_SET =
        new TokenSet( Token.PLUS, Token.MINUS, Token.MODULO );
    /** Set of tokens for term operators. */
    private final static TokenSet TERM_OPS_SET =
        new TokenSet( Token.TIMES, Token.DIVIDE );

    
    /*************************** Instance Variables ************************/
    /** The input token stream */
    private TokenStream tokens;
    /** The symbol table */
    private SymbolTable symtab;
    /** The object to report errors to */
    private Errors errors = ErrorHandler.getErrorHandler();
    // List of program counter values, corresponding to lines in source code, won't necessarily be consecutive numbers
    private List<Integer> pcValues = new ArrayList<Integer>();
    private String currentProcedure = "";
    // Auto-add a generic type to the symbol table for any unidentified types in variable declaration
    private boolean addGenericTypes = true;
    private Stack<StatementNode> activeLoops = new Stack<StatementNode>();
    // Name of the linked structure (i.e. finite sequence) in the specification if there is one 
    private String linkedStructureName = "";
    // Used to get the line number of a token at a given position, used to sync 'pc' with line numbers in source file
    private LinePositions linePositions = new LinePositions();
    /****************************** Constructor ****************************/
    /** Construct a parser with the given lexer 
     * @param tokens - stream of lexical tokens
     * @requires tokens != null;
     */
    public Parser( TokenStream tokens, LinePositions linePositions ) throws IOException {
        /** Set up an input token stream */
        this.tokens = tokens;
        /** Set up a symbol table. 
         * The initial value includes the predefined scope.
         */
        symtab = new SymbolTable();
        symtab.addType(Constants.SEQUENCE_MODEL_NAME, tokens.getPosn(), new Type.GenericType("FiniteSeq"));
        symtab.addVariable("null", tokens.getPosn(), new Type.ReferenceType(new Type.NullType()));
        this.linePositions = linePositions;
    }
    /***************************** Public Method ****************************/
    /** Parse the input stream. 
     *  @return constructed tree only if the stream was parsed correctly.
     */
    public Tree.ProgramNode parse() {
        Tree.ProgramNode program =  parseProgram( new TokenSet( Token.EOF ) );
        if( errors.hadErrors() ) {
            program = null;
        }
        errors.flush();
        return program;
    }
    
    /**
     * Returns the name of the linked structure in the specification if one exists. This is marked
     * in the PL/0 as being of type 'FiniteSeq'. Generally used as the abstract data structure.
     * 
     * @return The name of the linked structure if there is one, else the empty string
     */
    public String getLinkedStructureName() {
        return linkedStructureName;
    }
    
    /**
     * Returns the list of allowed program counters, corresponding to the line numbers in the source
     * file that represent statements
     * 
     * @return The list of valid program coutner values for the algorithms
     */
    public List<Integer> getPcValues() {
        return pcValues;
    }

    /**************************** Parsing Methods ***************************/

    /** RULE: Program -> Block ENDOFFILE */
    private Tree.ProgramNode parseProgram( TokenSet recoverSet ) {
        if( !tokens.beginRule( "Program", BLOCK_START_SET, recoverSet ) ) {
            return null;
        }
        assert tokens.isIn( BLOCK_START_SET );
        List<Type> retTypes = new ArrayList<Type>();
        retTypes.add(new Type.VoidType());
        SymEntry.ProcedureEntry proc = 
            symtab.addProcedure( "<Main>", tokens.getPosn(), retTypes, 
                    new ExpNode.ArgumentsNode(new ExpNode.EmptyNode(tokens.getPosn())) );
        if( proc  == null ) {
            fatal( "Could not add main program to symbol table" );
        }
        Scope blockLocals = symtab.newScope( proc );
        proc.setLocalScope( blockLocals );
        Tree.BlockNode block = parseBlock( recoverSet );
        block.setBlockLocals( blockLocals );
        symtab.leaveScope();
        /* We can't use match because there is nothing following end of file */
        tokens.endRule( "Program", recoverSet );
        return new Tree.ProgramNode( block.getPosition(), symtab, block );
    }
    /** RULE: Block -> { Declaration } CompoundStatement */
    private Tree.BlockNode parseBlock( TokenSet recoverSet ) {
        DeclNode.DeclListNode procedures = new DeclNode.DeclListNode();
        if( !tokens.beginRule("Block", BLOCK_START_SET, recoverSet)) {
            return new Tree.BlockNode( tokens.getPosn(), procedures, 
                    new StatementNode.ErrorNode( tokens.getPosn(), linePositions.getLineNumber(tokens.getPosn())) );
        }
        assert tokens.isIn( BLOCK_START_SET );
        while( tokens.isIn( DECLARATION_START_SET ) ) {
            procedures = parseDeclaration( procedures, 
                        recoverSet.union( BLOCK_START_SET ) );
        }
        if(tokens.isMatch(Token.EOF)) {
            tokens.endRule("Block", recoverSet );
            return new Tree.BlockNode(tokens.getPosn(), procedures, 
                    new StatementNode.EmptyNode(tokens.getPosn(), linePositions.getLineNumber(tokens.getPosn()) ));
        }
        pcValues.add(linePositions.getLineNumber(tokens.getPosn()));
        StatementNode statements = parseCompoundStatement( recoverSet );
        tokens.endRule( "Block", recoverSet );
        return new Tree.BlockNode( statements.getPosition(),
                                    procedures, statements );
    }
    /** RULE:
     *  Declaration -> ConstDefList | TypeDefList | VarDeclList | ProcedureDef 
     */
    private DeclNode.DeclListNode parseDeclaration( 
            DeclNode.DeclListNode procedures, TokenSet recoverSet ) {
        assert tokens.isIn( DECLARATION_START_SET );
        tokens.beginRule( "Declaration", DECLARATION_START_SET ); /* cannot fail */
        if( tokens.isMatch( Token.KW_CONST ) ) {
            parseConstDefList( recoverSet );
        } else if( tokens.isMatch( Token.KW_TYPE ) ) {
            parseTypeDefList( recoverSet );
        } else if( tokens.isMatch( Token.KW_VAR ) ) {
            DeclNode.VarListNode var = parseVarDeclList( recoverSet );
            procedures.addDeclaration( var );
        } else if( tokens.isMatch( Token.KW_PROCEDURE ) ) {
            DeclNode.ProcedureNode proc = parseProcedureDef( recoverSet );
            procedures.addDeclaration( proc );
        } else { // cannot get here
            errors.fatal( "parseDeclaration", tokens.getPosn() );
        }
        tokens.endRule( "Declaration", recoverSet );
        return procedures;
    }
    /** Rule: ConstDefList -> KW_CONST ConstDef { ConstDef } */
    private void parseConstDefList( TokenSet recoverSet ) {
        assert tokens.isMatch( Token.KW_CONST );
        tokens.beginRule( "Constant Definition List", Token.KW_CONST ); /* can't fail */
        tokens.match( Token.KW_CONST );
        do {
            parseConstDef( recoverSet.union( Token.IDENTIFIER ) );
        } while( tokens.isMatch( Token.IDENTIFIER ) );
        tokens.endRule( "Constant Definition List", recoverSet );
    }
    /** Rule: ConstDef -> IDENTIFIER EQUALS Constant SEMICOLON */
    private void parseConstDef( TokenSet recoverSet ) {
        if( !tokens.beginRule("Constant Definition", Token.IDENTIFIER, recoverSet)){
            return;
        }
        assert tokens.isMatch( Token.IDENTIFIER );
        String name = tokens.getName();
        Position posn = tokens.getPosn();
        tokens.match( Token.IDENTIFIER );    /* cannot fail */
        tokens.match( Token.EQUALS, CONSTANT_START_SET );
        ConstExp tree = 
            parseConstant( recoverSet.union( Token.SEMICOLON ) );
        if( symtab.addConstant( name, posn, tree ) == null ) {
                errors.error( "Constant identifier " + name + 
                    " already declared in this scope", posn );
        }
        tokens.match( Token.SEMICOLON, recoverSet );
        tokens.endRule( "Constant Definition", recoverSet );
    }
    /** Rule: Constant -> NUMBER | IDENTIFIER | MINUS Constant */
    private ConstExp parseConstant( TokenSet recoverSet ) {
        if( !tokens.beginRule( "Constant", CONSTANT_START_SET, recoverSet ) ) {
            /* Defaults to error node on error */
            return new ConstExp.ErrorNode( tokens.getPosn(), 
                    symtab.getCurrentScope() );
        }
        assert tokens.isIn( CONSTANT_START_SET ); 
        ConstExp tree;  
        if( tokens.isMatch( Token.NUMBER ) ) {
            tree = new ConstExp.NumberNode( tokens.getPosn(), 
                     symtab.getCurrentScope(), Predefined.INTEGER_TYPE, 
                     tokens.getIntValue() );
            tokens.match( Token.NUMBER ); /* cannot fail */
        } else if( tokens.isMatch( Token.IDENTIFIER ) ) {
            tree = new ConstExp.ConstIdNode( tokens.getPosn(),
                    symtab.getCurrentScope(), tokens.getName());
            tokens.match( Token.IDENTIFIER ); /* cannot fail */
        } else if( tokens.isMatch( Token.MINUS ) ) {
            Position pos = tokens.getPosn();
            tokens.match( Token.MINUS ); /* cannot fail */
            tree = parseConstant( recoverSet );
            tree = new ConstExp.NegateNode( pos, 
                    symtab.getCurrentScope(), tree );
        } else {
            tree = null;
            fatal( "parseConstant" ); /* cannot get here */
        }
        tokens.endRule( "Constant", recoverSet );
        return tree;
    }
    /** Rule: TypeDefList -> KW_TYPE TypeDef { TypeDef }  */
    private void parseTypeDefList( TokenSet recoverSet ) {
        assert tokens.isMatch( Token.KW_TYPE );
        tokens.beginRule( "Type Definition List", Token.KW_TYPE ); /* cannot fail */
        tokens.match( Token.KW_TYPE );
        do {
            parseTypeDef( recoverSet.union( TYPE_DEF_START_SET ) );
        } while( tokens.isIn( TYPE_DEF_START_SET ) );
        tokens.endRule( "Type Definition List", recoverSet );
    }
    /** Rule: TypeDef -> IDENTIFIER EQUALS Type SEMICOLON | KW_OBJECT IDENTIFIER EQUALS ObjType SEMICOLON */
    private void parseTypeDef( TokenSet recoverSet ) {
        if( !tokens.beginRule("Type Definition", TYPE_DEF_START_SET, recoverSet ) ) {
            return;
        }
        assert tokens.isIn( TYPE_DEF_START_SET );
        boolean isObject = false;
        if(tokens.isMatch(Token.KW_OBJECT)) {
            isObject = true;
            tokens.match(Token.KW_OBJECT); /* cannot fail */
        }
        String name = tokens.getName();
        Position posn = tokens.getPosn();
        tokens.match( Token.IDENTIFIER, recoverSet.union( Token.EQUALS ) );
        tokens.match( Token.EQUALS, TYPE_START_SET );
        Type type = null;
        if(isObject) {
            type = parseObjectType( recoverSet.union( Token.SEMICOLON ), name );
        } else {
            type = parseType( recoverSet.union( Token.SEMICOLON ) );
            
        }
        if( symtab.addType( name, posn, type) == null ){
            errors.error( "Type identifier " + name + 
                   " already declared in this scope", posn );
        }
        tokens.match( Token.SEMICOLON, recoverSet );
        tokens.endRule( "Type Definition", recoverSet );
    }
    /** Rule: ObjType -> LPAREN VarDeclList RPAREN */
    private Type parseObjectType( TokenSet recoverSet, String name ) {
        if(! tokens.beginRule("Object Type", Token.LCURLY, recoverSet )) {
            return Type.ERROR_TYPE;
        }
        assert tokens.isMatch(Token.LCURLY);
        tokens.match(Token.LCURLY, recoverSet.union(Token.KW_VAR));
        addGenericTypes = false;
        DeclNode.VarListNode varList = parseVarDeclList( recoverSet.union(Token.RCURLY ) );
        addGenericTypes = true;
        tokens.match(Token.RCURLY, recoverSet);
        Type.ObjectType type = new Type.ObjectType(name, varList);
        tokens.endRule("Object Type", recoverSet);
        return type;
    }
    /** Rule: Type -> TypeIdentifier | SubrangeType */
    private Type parseType( TokenSet recoverSet ) {        
        if( ! tokens.beginRule( "Type", TYPE_START_SET, recoverSet ) ) {
            return Type.ERROR_TYPE;
        }
        assert tokens.isIn( TYPE_START_SET );
        Type type = null;
        if( tokens.isMatch( Token.IDENTIFIER ) ) {
            type = parseTypeIdentifier( recoverSet );
        } else if( tokens.isMatch( Token.LBRACKET ) ) {
            type = parseSubrangeType( recoverSet );
        } else {
            errors.fatal( "parseType", tokens.getPosn() );
        }
        tokens.endRule( "Type", recoverSet );
        return type;
    }
    /** Rule: SubrangeType -> LBRACKET Constant RANGE Constant RBRACKET */
    private Type parseSubrangeType( TokenSet recoverSet ) {        
        if( ! tokens.beginRule( "Subrange Type", Token.LBRACKET, recoverSet ) ) {
            return Type.ERROR_TYPE;
        }
        assert tokens.isMatch( Token.LBRACKET );
        tokens.match( Token.LBRACKET ); /* cannot fail */
        ConstExp lower, upper;
        lower = parseConstant( recoverSet.union( Token.RANGE ) );
        tokens.match( Token.RANGE, CONSTANT_START_SET );
        upper = parseConstant( recoverSet.union( Token.RBRACKET ) );
        tokens.match( Token.RBRACKET, recoverSet );
        tokens.endRule( "Type", recoverSet );
        return new Type.SubrangeType( lower, upper );
    }
    /** Rule: TypeIdentifier -> IDENTIFIER */
    private Type parseTypeIdentifier( TokenSet recoverSet ) {
        if( !tokens.beginRule("Type Identifier", Token.IDENTIFIER, recoverSet) ) {
            return Type.ERROR_TYPE;
        }
        assert tokens.isMatch( Token.IDENTIFIER );
        String name = tokens.getName();
        Position posn = tokens.getPosn();
        tokens.match( Token.IDENTIFIER );    /* cannot fail */
        tokens.endRule( "Type Identifier", recoverSet );
        if(name.equals("void")) return new Type.VoidType();
        return new Type.IdRefType( name, symtab.getCurrentScope(), posn );
    }
    /** Rule: VarDeclList -> KW_VAR VarDecl { VarDecl }  */
    private DeclNode.VarListNode parseVarDeclList( TokenSet recoverSet ) {
        assert tokens.isMatch( Token.KW_VAR );
        tokens.beginRule( "Variable Declaration List", Token.KW_VAR ); // cannot fail
        tokens.match( Token.KW_VAR ); /* cannot fail */
        DeclNode.VarListNode result = new DeclNode.VarListNode();
        do {
            NameType var = parseVarDecl( recoverSet.union( VAR_DECL_START_SET ) );
            result.addVar(var.name, var.type, var.isGlobal, var.isAbstract);
        } while( tokens.isIn( VAR_DECL_START_SET ) ); 
        tokens.endRule( "Variable Declaration List", recoverSet );
        return result;
    }
    private class NameType {
        public String name;
        public Type type;
        public boolean isGlobal;
        public boolean isAbstract;
    }
    /** Rule: VarDecl -> {KW_GLOBAL | KW_ABSTRACCT} IDENTIFIER COLON TypeIdentifier SEMICOLON */
    private NameType parseVarDecl( TokenSet recoverSet ) {
        NameType result = new NameType();
        boolean isGlobal = false;
        boolean isAbstract = false;
        if(!tokens.beginRule("Variable Declaration", VAR_DECL_START_SET, recoverSet)) {
            return result;
        }
        assert tokens.isIn( VAR_DECL_START_SET );
        if(tokens.isMatch(Token.KW_GLOBAL)) {
            tokens.match(Token.KW_GLOBAL); /* cannot fail */
            isGlobal = true;
        } else if (tokens.isMatch(Token.KW_ABSTRACT)) {
            tokens.match(Token.KW_ABSTRACT); /* cannot fail */
            isAbstract = true;
        }
        String name = tokens.getName();
        Position posn = tokens.getPosn();
        tokens.match( Token.IDENTIFIER );     /* cannot fail */
        tokens.match( Token.COLON, TYPE_START_SET );
        Type type = parseTypeIdentifier( recoverSet.union( Token.SEMICOLON ) );
        if(type instanceof Type.IdRefType) {
            Type.IdRefType ref = (Type.IdRefType) type;
            TypeEntry entry = symtab.lookupType(ref.getName());
            if(entry != null) type = entry.getType();
            if(ref.getName().equals(syms.Constants.SEQUENCE_MODEL_NAME)) {
                linkedStructureName = name;
            } else if (entry == null && addGenericTypes) {
                symtab.addType(ref.getName(), tokens.getPosn(), new Type.GenericType(ref.getName()));
            }
        }
        // The type of a variable must be a reference type
        if( symtab.addVariable( name, posn, 
                new Type.ReferenceType(type), isGlobal, isAbstract ) == null ) {
            errors.error( "Variable identifier " + name + 
                   " already declared in this scope", posn );
        }
        result.name = name;
        result.type = type;
        result.isGlobal = isGlobal;
        result.isAbstract = isAbstract;
        tokens.match( Token.SEMICOLON, recoverSet );
        tokens.endRule( "Variable Declaration", recoverSet );
        return result;
    }
    /** Rule: ProcedureDef -> ProcedureHead EQUALS Block SEMICOLON */
    private DeclNode.ProcedureNode parseProcedureDef( TokenSet recoverSet ) {
        assert tokens.isMatch( Token.KW_PROCEDURE );
        tokens.beginRule( "Procedure Definition", Token.KW_PROCEDURE ); // can't fail
        /* A common syntax error is to forget the EQUALS, hence the 
         * recovery set contains tokens that can follow the EQUALS as well.
         * In general the recovery set can include tokens appearing later in
         * the production than immediately following tokens.
         */
        SymEntry.ProcedureEntry procEntry = parseProcedureHead( 
                recoverSet.union( Token.EQUALS ).union( BLOCK_START_SET ) );
        Scope blockLocals = symtab.newScope( procEntry );
        procEntry.setLocalScope( blockLocals );
        tokens.match( Token.EQUALS, BLOCK_START_SET );
        int initPc = linePositions.getLineNumber(tokens.getPosn());;
        Tree.BlockNode block = parseBlock(recoverSet.union(Token.SEMICOLON));
        block.setBlockLocals( blockLocals );
        symtab.leaveScope();
        tokens.match( Token.SEMICOLON, recoverSet );
        tokens.endRule( "Procedure Definition", recoverSet );
        return new DeclNode.ProcedureNode( procEntry, block, initPc );
    }
    /** Rule: ProcedureHead -> (TYPE | (LPAREN Type {COMMA Type} RPAREN)) KW_PROCEDURE IDENTIFIER LPAREN ARGSLIST RPAREN */
    private SymEntry.ProcedureEntry parseProcedureHead(TokenSet recoverSet) {
        assert tokens.isMatch( Token.KW_PROCEDURE );
        tokens.beginRule( "Procedure Header", Token.KW_PROCEDURE ); /* can't fail */
        SymEntry.ProcedureEntry procEntry;
        tokens.match( Token.KW_PROCEDURE );
        List<Type> returnTypes = new ArrayList<Type>();
        // List of return types
        if(tokens.isMatch(Token.LPAREN)) { 
            tokens.match(Token.LPAREN); // Cannot fail
            Type returnType = parseTypeIdentifier(recoverSet.union(Token.IDENTIFIER, Token.COMMA, Token.RPAREN));
            returnTypes.add(returnType);
            while(tokens.isMatch(Token.COMMA)) {
                tokens.match(Token.COMMA); // Cannot fail
                returnType = parseTypeIdentifier(recoverSet.union(Token.IDENTIFIER, Token.COMMA, Token.RPAREN));
                returnTypes.add(returnType);
            }
            tokens.match(Token.RPAREN, Token.IDENTIFIER);
        // Single return type
        } else {
            Type returnType = parseTypeIdentifier(recoverSet.union(Token.IDENTIFIER));
            if(!(returnType instanceof Type.VoidType)) {
                returnTypes.add(returnType);
            }
        }
        if( tokens.isMatch( Token.IDENTIFIER ) ) {
            String procName = tokens.getName();
            currentProcedure = procName;
            Position procPos = tokens.getPosn();
            tokens.match( Token.IDENTIFIER, Token.LPAREN );
            tokens.match( Token.LPAREN, Token.IDENTIFIER );
            ExpNode args = parseArgsDeclarationList(recoverSet.union(Token.RPAREN));
            procEntry = symtab.addProcedure(procName,procPos, returnTypes, args);
            if( procEntry  == null ) {
                procEntry = new SymEntry.ProcedureEntry( procName, 
                        procPos, symtab.getCurrentScope(), returnTypes, args);
                errors.error( "Procedure identifier " + procName +
                       " already declared in this scope", procPos  );
            }
            
            tokens.match( Token.RPAREN, recoverSet );
            tokens.endRule( "Procedure Header", recoverSet );
        } else {
            currentProcedure = "";
            /* Provide dummy procedure entry (not in the symbol table) */
            List<ExpNode> argsList = new ArrayList<ExpNode>();
            argsList.add(new ExpNode.EmptyNode(tokens.getPosn()));
            ExpNode args = new ExpNode.ArgumentsNode(argsList);
            List<Type> retTypes = new ArrayList<Type>();
            retTypes.add(new Type.VoidType());
            procEntry = new SymEntry.ProcedureEntry( "<undefined>", 
                    tokens.getPosn(), symtab.getCurrentScope(), 
                    retTypes, args);
            tokens.match( Token.IDENTIFIER, Token.LPAREN );
            tokens.match( Token.LPAREN, Token.RPAREN );
            tokens.match( Token.RPAREN, recoverSet );
            tokens.endRule( "Procedure Header", recoverSet );
        }
                
        return procEntry;
    }
    /** Rule: CompoundStatement -> BEGIN StatementList END  */
    private StatementNode parseCompoundStatement( TokenSet recoverSet ) {
        /* In case KW_BEGIN is missing, the recovery set is non-standard
         * and contains tokens that can start a statement.
         */
        if( !tokens.beginRule( "Compound Statement", COMPOUND_STATEMENT_START_SET, recoverSet ) ) {
            return new StatementNode.ListNode( tokens.getPosn(), linePositions.getLineNumber(tokens.getPosn()) );
        }
        boolean usingBrackets = true;
        if(tokens.isMatch(Token.KW_BEGIN)) {
            usingBrackets = false;
            tokens.match(Token.KW_BEGIN, STATEMENT_START_SET);
        } else {
            tokens.match(Token.LCURLY, STATEMENT_START_SET);
        }
        Token endToken = Token.KW_END;
        if(usingBrackets) {
            endToken = Token.RCURLY;
        }
        StatementNode result = 
            parseStatementList( recoverSet.union( endToken ));
        tokens.match( endToken, recoverSet );
        tokens.endRule( "Compound Statement", recoverSet );
        return result;
    }
    /** Rule: StatementList -> Statement { SEMICOLON Statement }  */
    private StatementNode parseStatementList( TokenSet recoverSet ) {
        // Initialize result to an empty list of statements
        StatementNode.ListNode result = 
                new StatementNode.ListNode( tokens.getPosn(), linePositions.getLineNumber(tokens.getPosn()) );
        if( !tokens.beginRule("Statement List",STATEMENT_START_SET.union(Token.RCURLY, Token.KW_END),recoverSet) ) {
            return result;
        }
        assert tokens.isIn( STATEMENT_START_SET.union(Token.RCURLY, Token.KW_END) );
        
        // Allow an empty compound statement, may end with either '}' or 'end'
        if(tokens.isMatch(Token.RCURLY) || tokens.isMatch(Token.KW_END)) {
            tokens.endRule( "Statement List", recoverSet );
            return result;
        }
        
        StatementNode s = 
            parseStatement( recoverSet.union( Token.SEMICOLON ) );
        result.addStatement( s );
        result.setPc(s.getPc());
        
        while( tokens.isMatch( Token.SEMICOLON ) ) {
            tokens.match( Token.SEMICOLON );
            s = parseStatement( recoverSet.union( Token.SEMICOLON ) );
            result.addStatement( s );
        }
        tokens.endRule( "Statement List", recoverSet );
        return result;
    }
    /** Rule: Statement -> Assignment | WhileStatement
     *                     | DoWhileStatement | RepeatUntilStatement | IfStatement | CallStatement
     *                  | CompoundStatement | CasOperation | BreakStatement 
     *                  | ContinueStatement | ReturnStatement
     */
    private StatementNode parseStatement( TokenSet recoverSet ) {
        StatementNode result;
        if ( !tokens.beginRule( "Statement", STATEMENT_START_SET, recoverSet ) ) {
            return new StatementNode.ErrorNode( tokens.getPosn(), linePositions.getLineNumber(tokens.getPosn()) );
        }
        switch( tokens.getKind() ) {
        case IDENTIFIER:
            result = parseAssignment( recoverSet ); 
            break;
        case KW_WHILE:
            result = parseWhileStatement( recoverSet ); 
            break;
        case KW_DO:
            result = parseDoWhileStatement( recoverSet );
            break;
        case KW_IF:
            result = parseIfStatement( recoverSet ); 
            break;
        case KW_CALL:
            result = parseCallStatement( recoverSet ); 
            break;
        case KW_BEGIN:
        case LCURLY: 
            result = parseCompoundStatement( recoverSet ); 
            break;
        case KW_CAS:
            result = parseCasStatement( recoverSet );
            break;
        case KW_REPEAT: 
            result = parseRepeatUntilStatement( recoverSet );
            break;
        case KW_BREAK: 
            result = parseBreakStatement( recoverSet );
            break;
        case KW_CONTINUE: 
            result = parseContinueStatement( recoverSet );
            break;
        case KW_RETURN:
            result = parseReturnStatement( recoverSet );
            break;
        case KW_LOCK: 
            result = parseLockStatement( recoverSet );
            break;
        case KW_UNLOCK:
            result = parseUnlockStatement( recoverSet );
            break;
        default:
            fatal( "parse Statement " );
            result = new StatementNode.ErrorNode( tokens.getPosn(), linePositions.getLineNumber(tokens.getPosn()) );
        }
        tokens.endRule( "Statement", recoverSet );
        return result;
    }
    /** Rule: Assignment -> LValue ASSIGN (Condition | KW_NEW Identifier LPAREN RPAREN) */
    private StatementNode.AssignmentNode parseAssignment(TokenSet recoverSet) {
        assert tokens.isIn( LVALUE_START_SET );
        tokens.beginRule( "Assignment", LVALUE_START_SET, recoverSet );
        /* Non-standard recovery set includes EQUALS because a common syntax
         * error is to use EQUALS instead of ASSIGN.
         */
        ExpNode left = parseLValue( 
                recoverSet.union( Token.ASSIGN, Token.EQUALS ) );
        Position pos = tokens.getPosn();
        tokens.match( Token.ASSIGN, CONDITION_START_SET.union(Token.KW_NEW) );
        
        ExpNode right = new ExpNode.EmptyNode(pos);
        if(tokens.isMatch(Token.KW_NEW)) {
            tokens.match(Token.KW_NEW); // Cannot fail
            ExpNode.IdentifierNode lValue = (ExpNode.IdentifierNode) parseLValue( recoverSet.union(Token.LPAREN));
            right = new ExpNode.NewObjectNode( pos, lValue.getId());
            tokens.match(Token.LPAREN, Token.RPAREN);
            tokens.match(Token.RPAREN, recoverSet );
        } else {
            right = parseCondition( recoverSet );
        }
        tokens.endRule( "Assignment", recoverSet );
        pcValues.add(linePositions.getLineNumber(pos));
        return new StatementNode.AssignmentNode( pos, linePositions.getLineNumber(pos), left, right );
    }
    /** Rule: WhileStatement -> KW_WHILE Condition KW_DO Statement */
    private StatementNode parseWhileStatement( TokenSet recoverSet ) {
        assert tokens.isMatch( Token.KW_WHILE );
        tokens.beginRule( "While Statement", Token.KW_WHILE ); // cannot fail
        Position pos = tokens.getPosn();
        tokens.match( Token.KW_WHILE ); /* cannot fail */
        int startPc = linePositions.getLineNumber(tokens.getPosn());
        ExpNode cond = parseCondition( recoverSet.union( Token.KW_DO ) );
        if(!(cond instanceof ExpNode.IdentifierNode)) {
            pcValues.add(startPc);
        }
        tokens.match( Token.KW_DO, STATEMENT_START_SET );
        StatementNode.WhileNode node = new StatementNode.WhileNode( pos, startPc, cond, null );
        activeLoops.add(node);
        StatementNode statement = parseStatement( recoverSet );
        activeLoops.pop();
        node.setLoopStatement(statement);
        int endPc = linePositions.getLineNumber(tokens.getPosn());
        node.setEndPc(endPc);
        tokens.endRule( "While Statement", recoverSet );
        return node;
    }
    /** Rule: DoWhileStatement -> KW_DO Statement KW_WHILE Condition */
    private StatementNode parseDoWhileStatement( TokenSet recoverSet ) {
        assert tokens.isMatch( Token.KW_DO );
        tokens.beginRule( "Do-While Statement", Token.KW_DO ); // cannot fail
        Position pos = tokens.getPosn();
        tokens.match( Token.KW_DO); /* cannot fail */
        StatementNode.DoWhileNode node = new StatementNode.DoWhileNode(pos, linePositions.getLineNumber(pos), null, null);
        activeLoops.add(node);
        StatementNode statement = parseStatement( recoverSet.union( Token.KW_WHILE) );
        activeLoops.pop();
        tokens.match( Token.KW_WHILE, CONDITION_START_SET );
        ExpNode cond = parseCondition( recoverSet );
        tokens.endRule( "Do-While Statement", recoverSet );
        node.setCondition(cond);
        node.setLoopStatement(statement);
        node.setPc(statement.getPc());
        int endPc = linePositions.getLineNumber(tokens.getPosn());
        pcValues.add(endPc);
        node.setEndPc(endPc);
        return node;
    }
    /** Rule: RepeatUntilStatement -> KW_REPEAT Statement KW_UNTIL Condition */
    private StatementNode parseRepeatUntilStatement( TokenSet recoverSet ) {
        assert tokens.isMatch( Token.KW_REPEAT );
        tokens.beginRule( "Repeat-Until Statement", Token.KW_REPEAT ); // cannot fail
        Position pos = tokens.getPosn();
        tokens.match( Token.KW_REPEAT); /* cannot fail */
        StatementNode.RepeatUntilNode node = new StatementNode.RepeatUntilNode( pos, 0, null, null );
        activeLoops.add(node);
        StatementNode statement = parseStatement( recoverSet.union( Token.KW_UNTIL) );
        activeLoops.pop();
        tokens.match( Token.KW_UNTIL, CONDITION_START_SET );
        ExpNode cond = parseCondition( recoverSet );
        tokens.endRule( "Repeat-Until Statement", recoverSet );
        node.setCondition(cond);
        node.setLoopStatement(statement);
        node.setPc(statement.getPc());
        int endPc = linePositions.getLineNumber(tokens.getPosn());
        pcValues.add(endPc);
        node.setEndPc(endPc);
        return node;
    }
    /** Rule: IfStatement -> KW_IF Condition KW_THEN Statement KW_ELSE Statement
     */
    private StatementNode parseIfStatement( TokenSet recoverSet ) {
        assert tokens.isMatch( Token.KW_IF );
        tokens.beginRule( "If Statement", Token.KW_IF ); /* cannot fail */
        tokens.match( Token.KW_IF ); /* cannot fail */
        Position pos = tokens.getPosn();
        int tempPc = linePositions.getLineNumber(pos);
        pcValues.add(tempPc);
        ExpNode cond = parseCondition( recoverSet.union( Token.KW_THEN ) );
        tokens.match( Token.KW_THEN, STATEMENT_START_SET );
        StatementNode thenClause = 
            parseStatement( recoverSet.union( Token.KW_ELSE ) );
        StatementNode elseClause = new StatementNode.EmptyNode(pos, linePositions.getLineNumber(tokens.getPosn()));
        if(tokens.isMatch( Token.KW_ELSE )) {
            tokens.match( Token.KW_ELSE, STATEMENT_START_SET );
            elseClause = parseStatement( recoverSet );
        }
        tokens.endRule( "If Statement", recoverSet );
        return new StatementNode.IfNode( pos, tempPc, cond, thenClause, elseClause );
    }
    /** Rule: CallStatement -> KW_CALL IDENTIFIER LPAREN RPAREN */
    private StatementNode parseCallStatement( TokenSet recoverSet ) {
        assert tokens.isMatch( Token.KW_CALL );
        tokens.beginRule( "Call Statement", Token.KW_CALL ); // cannot fail
        tokens.match( Token.KW_CALL ); /* cannot fail */
        Position pos = tokens.getPosn();
        String procId;
        if( tokens.isMatch( Token.IDENTIFIER ) ) {
            procId = tokens.getName();
        } else {
            procId = "<noid>";
        }
        tokens.match( Token.IDENTIFIER, Token.LPAREN );
        tokens.match( Token.LPAREN, CONSTANT_START_SET );
        // Empty actual parameter list currently
        ExpNode argsList = parseArgumentsList(recoverSet.union(Token.RPAREN));
        tokens.match( Token.RPAREN, recoverSet );
        tokens.endRule( "Call Statement", recoverSet );
        int pc = linePositions.getLineNumber(pos);
        pcValues.add(pc);
        return new StatementNode.CallNode( pos, pc, procId, argsList);
    }
    /** Rule: ArgsList -> FACTOR {, FACTOR} */
    private ExpNode parseArgumentsList( TokenSet recoverSet ) {
        List<ExpNode> argsList = new ArrayList<ExpNode>();
        Position pos = tokens.getPosn();
        while(!tokens.isMatch(Token.RPAREN)) {
            argsList.add(parseFactor(recoverSet.union(Token.COMMA)));
            if(!tokens.isMatch(Token.RPAREN))
            tokens.match( Token.COMMA, recoverSet.union(CONSTANT_START_SET));
        }
        if(argsList.size() == 0) {
            argsList.add(new ExpNode.EmptyNode(pos));
        }
        return new ExpNode.ArgumentsNode(argsList);
    }
    /** Rule: ArgsDeclList -> TYPE IDENTIFIER {, TYPE IDENTIFIER} */
    private ExpNode parseArgsDeclarationList( TokenSet recoverSet ) {
        List<ExpNode> argsList = new ArrayList<ExpNode>();
        Position pos = tokens.getPosn();
        while(!tokens.isMatch(Token.RPAREN)) {
            Type type = parseType(recoverSet.union(CONSTANT_START_SET));
            ExpNode.IdentifierNode arg = (ExpNode.IdentifierNode) parseLValue(recoverSet.union(Token.COMMA));
            arg.setType(type);
            argsList.add(arg);
            symtab.addVariable(arg.getId(), arg.getPosition(), new Type.ReferenceType(type));
            if(!tokens.isMatch(Token.RPAREN))
            tokens.match( Token.COMMA, recoverSet.union(CONSTANT_START_SET));
        }
        if(argsList.size() == 0) {
            argsList.add(new ExpNode.EmptyNode(pos));
        }
        return new ExpNode.ArgumentsNode(argsList);
    }
    /** Rule: ReturnStatement -> KW_RETURN KW_VOID | KW_RETURN Exp | KW_RETURN LPAREN Exp {COMMA Exp} RPAREN */
    private StatementNode parseReturnStatement( TokenSet recoverSet ) {
        assert tokens.isMatch( Token.KW_RETURN );
        tokens.beginRule( "Return Statement", Token.KW_RETURN ); // cannot fail
        Position pos = tokens.getPosn();
        tokens.match( Token.KW_RETURN ); /* cannot fail */
        StatementNode newNode = null;
        List<ExpNode> retVals = new ArrayList<ExpNode>();
        // Void return, with syntax return void
        if(tokens.isMatch(Token.IDENTIFIER) && tokens.getName().equals("void")) {
            tokens.match(Token.IDENTIFIER); /* cannot fail */
            newNode = new StatementNode.ReturnNode( pos , linePositions.getLineNumber(pos), retVals, currentProcedure, true);
        // Return set of items, with syntax return (a, b, c)
        } else if  (tokens.isMatch( Token.LPAREN ) ) {
            tokens.match( Token.LPAREN ); // cannot fail
            ExpNode exp = parseExp( recoverSet.union( Token.RPAREN, Token.COMMA ) );
            retVals.add(exp);
            while( tokens.isMatch( Token.COMMA ) ) {
                tokens.match(Token.COMMA);
                exp = parseExp( recoverSet.union( Token.RPAREN, Token.COMMA ) );
                retVals.add(exp);
            }
            tokens.match( Token.RPAREN, recoverSet );
            newNode = new StatementNode.ReturnNode(pos, linePositions.getLineNumber(pos), retVals, currentProcedure, false);
        // Return a single item, with syntax return exp
        } else {
            ExpNode exp = parseExp( recoverSet.union(STATEMENT_START_SET) );
            retVals.add(exp);
            newNode = new StatementNode.ReturnNode( pos, linePositions.getLineNumber(pos), retVals, currentProcedure, false);
        }
        pcValues.add(linePositions.getLineNumber(pos));
        tokens.endRule( "Return Statement", recoverSet );
        return newNode;
    }
    /** Rule: BreakStatement -> KW_BREAK */
    private StatementNode parseBreakStatement( TokenSet recoverSet ) {
        assert tokens.isMatch( Token.KW_BREAK );
        tokens.beginRule( "Break Statement", Token.KW_BREAK); // cannot fail
        Position pos = tokens.getPosn();
        StatementNode enclosingLoop = activeLoops.empty() ? null : activeLoops.peek();
        pcValues.add(linePositions.getLineNumber(pos));
        StatementNode newNode = new StatementNode.BreakNode(pos, linePositions.getLineNumber(pos), enclosingLoop);
        tokens.match( Token.KW_BREAK); /* cannot fail */
        tokens.endRule( "Break Statement", recoverSet );
        return newNode;
    }
    /** Rule ContinueStatement -> KW_CONTINUE */
    private StatementNode parseContinueStatement( TokenSet recoverSet ) {
    	assert tokens.isMatch( Token.KW_CONTINUE );
        tokens.beginRule( "Continue Statement", Token.KW_CONTINUE); // cannot fail
        Position pos = tokens.getPosn();
        StatementNode enclosingLoop = activeLoops.empty() ? null : activeLoops.peek();
        pcValues.add(linePositions.getLineNumber(pos));
        StatementNode newNode = new StatementNode.ContinueNode(pos, linePositions.getLineNumber(pos), enclosingLoop);
        tokens.match( Token.KW_CONTINUE); /* cannot fail */
        tokens.endRule( "Continue Statement", recoverSet );
        return newNode;
    }
    /** Rule: Condition -> [LOG_NOT] RelCondition | CasOperation*/
    private ExpNode parseCondition( TokenSet recoverSet ) {
        boolean hasLogicalNot = false;
        if(tokens.isMatch(Token.LOG_NOT)) {
            tokens.match(Token.LOG_NOT); /* Cannot fail */
            hasLogicalNot = true;
        }
        if(tokens.isMatch(Token.KW_CAS)) {
            return parseCasOperation(recoverSet, hasLogicalNot);
        } else if (tokens.isMatch(Token.KW_CALL)) {
            StatementNode call = parseCallStatement(recoverSet);
            return new ExpNode.CallNode(call.getPosition(), call);
        }
        return parseRelCondition( recoverSet, hasLogicalNot );
    }
    /** Rule: CasOperation -> KW_CAS LPAREN IDENTIFIER COMMA IDENTIFIER COMMA
     *                           IDENTIFIER RPAREN
     */
    private ExpNode parseCasOperation( TokenSet recoverSet, boolean hasLogicalNot ) {
        assert tokens.isMatch(Token.KW_CAS);
        tokens.beginRule("CAS Operation", Token.KW_CAS); /* cannot fail */
        tokens.match(Token.KW_CAS); /* cannot fail */
        Position pos = tokens.getPosn();
        tokens.match(Token.LPAREN, Token.IDENTIFIER);
        ExpNode oldValue = parseLValue( recoverSet.union( Token.COMMA ) );
        tokens.match(Token.COMMA, Token.IDENTIFIER);
        ExpNode compareValue = parseTerm( recoverSet.union( Token.COMMA ) );
        tokens.match(Token.COMMA, Token.IDENTIFIER);
        ExpNode newValue = parseTerm( recoverSet.union( Token.RPAREN ) );
        tokens.match(Token.RPAREN, STATEMENT_START_SET);
        tokens.endRule("CAS Operation", recoverSet); 
        return new ExpNode.CasNode(pos, oldValue, compareValue, newValue, hasLogicalNot);
    }
    private StatementNode parseCasStatement( TokenSet recoverSet ) {
        assert tokens.isMatch(Token.KW_CAS);
        tokens.beginRule("CAS Statement", Token.KW_CAS); /* cannot fail */
        tokens.match(Token.KW_CAS); /* cannot fail */
        Position pos = tokens.getPosn();
        tokens.match(Token.LPAREN, Token.IDENTIFIER);
        ExpNode oldValue = parseLValue( recoverSet.union( Token.COMMA ) );
        tokens.match(Token.COMMA, Token.IDENTIFIER);
        ExpNode compareValue = parseTerm( recoverSet.union( Token.COMMA ) );
        tokens.match(Token.COMMA, Token.IDENTIFIER);
        ExpNode newValue = parseTerm( recoverSet.union( Token.RPAREN ) );
        tokens.match(Token.RPAREN, STATEMENT_START_SET);
        tokens.endRule("CAS Statement", recoverSet); 
        pcValues.add(linePositions.getLineNumber(pos));
        return new StatementNode.CasNode(pos, linePositions.getLineNumber(pos), oldValue, compareValue, newValue);
    }
    
    /** Rule: Lock -> KW_LOCK */
    private StatementNode parseLockStatement( TokenSet recoverSet ) {
        tokens.beginRule( "Lock", Token.KW_LOCK, recoverSet );
        assert tokens.isMatch(Token.KW_LOCK);
        Position pos = tokens.getPosn();
        tokens.match(Token.KW_LOCK);
        tokens.endRule("Lock", recoverSet); 
        pcValues.add(linePositions.getLineNumber(pos));
        return new StatementNode.LockNode(pos, linePositions.getLineNumber(pos));
    }
    /** Rule: Unlock -> KW_UNLOCK */
    private StatementNode parseUnlockStatement( TokenSet recoverSet ) {
        tokens.beginRule( "Unlock", Token.KW_UNLOCK, recoverSet );
        assert tokens.isMatch(Token.KW_UNLOCK);
        Position pos = tokens.getPosn();
        tokens.match(Token.KW_UNLOCK);
        tokens.endRule("Unlock", recoverSet); 
        pcValues.add(linePositions.getLineNumber(pos));
        return new StatementNode.UnlockNode(pos, linePositions.getLineNumber(pos));
    }
    /** Rule: RelCondition -> Exp [ RelOp Exp ] */
    private ExpNode parseRelCondition( TokenSet recoverSet, boolean hasLogicalNot ) {
        if( !tokens.beginRule( "Condition", CONDITION_START_SET, recoverSet ) ) {
            return new ExpNode.ErrorNode( tokens.getPosn() );
        }
        assert tokens.isIn( CONDITION_START_SET );
        ExpNode cond = parseExp( recoverSet.union( REL_OPS_SET ) );
        if( tokens.isIn( REL_OPS_SET ) ) {
            Position pos = tokens.getPosn();
            Operator operatorCode = 
                parseRelOp( recoverSet.union( EXP_START_SET ) );
            ExpNode right = parseExp( recoverSet );
            cond = new ExpNode.OperatorNode( pos, operatorCode, 
                    new ExpNode.ArgumentsNode( cond, right ), hasLogicalNot);
        }
        tokens.endRule( "Condition", recoverSet );
        return cond;
    }
    /** Rule: RelOp -> EQUALS | NEQUALS | LEQUALS | LESS | GREATER | GEQUALS */
    private Operator parseRelOp( TokenSet recoverSet ) {
        assert tokens.isIn( REL_OPS_SET );
        tokens.beginRule( "RelOp", REL_OPS_SET ); // cannot fail
        Operator operatorCode = Operator.INVALID_OP;
        switch( tokens.getKind() ) {
        case EQUALS:
            operatorCode = Operator.EQUALS_OP;
            tokens.match( Token.EQUALS ); /* cannot fail */
            break;
        case NEQUALS:
            operatorCode = Operator.NEQUALS_OP;
            tokens.match( Token.NEQUALS ); /* cannot fail */
            break;
        case LESS:
            operatorCode = Operator.LESS_OP;
            tokens.match( Token.LESS ); /* cannot fail */
            break;
        case GREATER:
            operatorCode = Operator.GREATER_OP; 
            tokens.match( Token.GREATER ); /* cannot fail */
            break;
        case LEQUALS:
            operatorCode = Operator.LEQUALS_OP;
            tokens.match( Token.LEQUALS ); /* cannot fail */
            break;
        case GEQUALS:
            operatorCode = Operator.GEQUALS_OP;
            tokens.match( Token.GEQUALS ); /* cannot fail */
            break;
        default:
            fatal( "Unreachable branch in parseCondition" );
        }
        tokens.endRule( "RelOp", recoverSet );
        return operatorCode;
    }
    /** Rule: Exp -> [ PLUS | MINUS] Term { ( PLUS | MINUS | MODULO ) Term } */
    private ExpNode parseExp( TokenSet recoverSet ) {
        if( !tokens.beginRule( "Expression", EXP_START_SET, recoverSet ) ) {
            return new ExpNode.ErrorNode( tokens.getPosn() );
        }
        assert tokens.isIn( EXP_START_SET );
        boolean haveUnaryMinus = false;
        Position pos = tokens.getPosn();
        if( tokens.isMatch( Token.MINUS ) ) {
            haveUnaryMinus = true;
            tokens.match( Token.MINUS ); /* cannot fail */
        } else if( tokens.isMatch( Token.PLUS ) ) {
            tokens.match( Token.PLUS ); /* cannot fail */
        }
        ExpNode exp = parseTerm( recoverSet.union( EXP_OPS_SET ) );
        if( haveUnaryMinus ) {
            exp = new ExpNode.OperatorNode( pos, Operator.NEG_OP, exp );
        }
        while( tokens.isIn( EXP_OPS_SET ) ) {
            Operator operatorCode = Operator.INVALID_OP;
            pos = tokens.getPosn();
            if ( tokens.isMatch( Token.MINUS ) ) {
                operatorCode = Operator.SUB_OP;
                tokens.match( Token.MINUS ); /* cannot fail */
            } else if ( tokens.isMatch( Token.PLUS ) ) {
                operatorCode = Operator.ADD_OP;
                tokens.match( Token.PLUS ); /* cannot fail */
            } else if ( tokens.isMatch( Token.MODULO ) ) {
                operatorCode = Operator.MOD_OP;
                tokens.match( Token.MODULO ); /* cannot fail */
            } else {
                fatal( "Unreachable branch in parseExp" );
            }
            ExpNode right = parseTerm( recoverSet.union( EXP_OPS_SET ) );
            exp = new ExpNode.OperatorNode( pos, operatorCode, 
                    new ExpNode.ArgumentsNode( exp, right ) );
        }
        tokens.endRule( "Expression", recoverSet );
        return exp;
    }
    /** Rule: Term  -> Factor { ( TIMES | DIVIDE ) Factor }  */
    private ExpNode parseTerm( TokenSet recoverSet ) {
        if( !tokens.beginRule( "Term", TERM_START_SET, recoverSet ) ) {
            return new  ExpNode.ErrorNode( tokens.getPosn() );
        }
        assert tokens.isIn( TERM_START_SET );
        ExpNode term = parseFactor( recoverSet.union( TERM_OPS_SET ) );
        while( tokens.isIn( TERM_OPS_SET ) ) {
            Operator operatorCode = Operator.INVALID_OP;
            Position pos = tokens.getPosn();
            if ( tokens.isMatch( Token.TIMES ) ) {
                operatorCode = Operator.MUL_OP;
                tokens.match( Token.TIMES ); /* cannot fail */
            } else if ( tokens.isMatch( Token.DIVIDE ) ) {
                operatorCode = Operator.DIV_OP;
                tokens.match( Token.DIVIDE ); /* cannot fail */
            } else {
                fatal( "Unreachable branch in parseTerm" );
            }
            ExpNode right = parseFactor( recoverSet.union( TERM_OPS_SET ) );
            term = new ExpNode.OperatorNode( pos, operatorCode, 
                    new ExpNode.ArgumentsNode( term, right ) );
        }
        tokens.endRule( "Term", recoverSet );
        return term;
    }
    /** Rule: Factor -> LPAREN Condition RPAREN | NUMBER | LValue  */
    private ExpNode parseFactor( TokenSet recoverSet ) {
        if( !tokens.beginRule( "Factor", FACTOR_START_SET, recoverSet ) ) {
            return new ExpNode.ErrorNode( tokens.getPosn() );
        }
        assert tokens.isIn( FACTOR_START_SET );
        ExpNode result = null;
        if( tokens.isMatch( Token.IDENTIFIER ) ) {
            result = parseLValue( recoverSet );
        } else if( tokens.isMatch( Token.NUMBER ) ) {
            result = new ExpNode.ConstNode( tokens.getPosn(), 
                    Predefined.INTEGER_TYPE, tokens.getIntValue() );
            tokens.match( Token.NUMBER ); /* cannot fail */
        } else if( tokens.isMatch( Token.LPAREN ) ) {
            tokens.match( Token.LPAREN ); /* cannot fail */
            result = parseCondition( recoverSet.union( Token.RPAREN ) );
            tokens.match( Token.RPAREN, recoverSet );
        } else {
            fatal( "Unreachable branch in Factor" );
        }
        tokens.endRule( "Factor", recoverSet );
        return result;
    }
    /** Rule: LValue -> IDENTIFIER {PERIOD IDENTIFIER} */
    private ExpNode parseLValue( TokenSet recoverSet ) {
        if( !tokens.beginRule( "LValue", Token.IDENTIFIER, recoverSet ) ) {
            return new ExpNode.ErrorNode( tokens.getPosn() );
        }
        assert tokens.isMatch( Token.IDENTIFIER );
        Position position = tokens.getPosn();
        String id = tokens.getName();
        tokens.match(Token.IDENTIFIER);   
        while (tokens.isMatch(Token.PERIOD)) {
            tokens.match(Token.PERIOD, recoverSet.union(Token.IDENTIFIER)); 
            id = id.concat(".");
            String name = tokens.getName();
            tokens.match(Token.IDENTIFIER, recoverSet.union(Token.PERIOD));   
            id = id.concat(name);
        }
        ExpNode result = new ExpNode.IdentifierNode(position, id);
        tokens.endRule( "LValue", recoverSet );
        return result;
    }

/*********************** Private convenience Methods ************************/
    /** Signal a fatal error at the current token position */
    private void fatal( String m ) {
        errors.fatal( m, tokens.getPosn() );
    }
}
